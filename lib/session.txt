import { getIronSession, IronSession, SessionOptions } from 'iron-session';
import { cookies } from 'next/headers';
import { kv } from './kv';
import { nanoid } from 'nanoid';
import { SessionState } from '@/app/api/chat/flows/types'; // Import SessionState type
import { SessionStoreUnavailableError } from '@/app/api/chat/errors'; // Import the new custom error

// The structure of the session data is already in types.ts. We don't need to redefine it here.

// This is the type that will be stored in the cookie, just the ID.
interface SessionIdContainer {
  sessionId?: string;
}

const SESSION_TTL_SECONDS = 60 * 60 * 24; // 24 hours

export const sessionOptions: SessionOptions = {
    password: process.env.SECRET_COOKIE_PASSWORD as string,
    cookieName: 'ielts-ai-tutor-session',
    cookieOptions: {
      secure: process.env.NODE_ENV === 'production',
    },
};

// CORRECTLY DEFINED AND EXPORTED DEFAULT STATE
export const defaultSessionData: Omit<SessionState, 'sessionId'> = {
  currentStepId: '0_start',
  namedMemory: {},
  conversationHistory: [],
};

async function getSessionFromCookie(): Promise<IronSession<SessionIdContainer>> {
    return getIronSession<SessionIdContainer>(await cookies(), sessionOptions);
}

export async function getSession(): Promise<SessionState> {
  const session = await getSessionFromCookie();
  let sessionId = session.sessionId;
  let sessionData: SessionState | null = null;

  if (sessionId) {
    try {
      sessionData = await kv.get(sessionId);
    } catch (error) {
      console.error("[SESSION-CRITICAL] KV Error retrieving session:", error);
      throw new SessionStoreUnavailableError('The session store is currently unavailable during get.');
    }
  }

  // If the session data is null FROM a successful kv.get (e.g., expired key),
  // OR if there was no session ID in the cookie, we create a new one.
  if (!sessionData) {
    const newSessionId = nanoid();
    console.log(`[SESSION] No valid session found. Creating new session: ${newSessionId}`);
    sessionData = { sessionId: newSessionId, ...defaultSessionData };
    
    try {
      await kv.set(newSessionId, sessionData, { ex: SESSION_TTL_SECONDS });
      session.sessionId = newSessionId;
      await session.save();
    } catch (error) {
        console.error("[SESSION-CRITICAL] KV Error creating new session:", error);
        throw new SessionStoreUnavailableError('The session store is currently unavailable during set.');
    }
  }

  return sessionData;
}

export async function saveSession(data: SessionState): Promise<void> {
  if (!data.sessionId) {
    throw new Error("[KV-ERROR] Attempted to save session without a session ID.");
  }
  try {
    await kv.set(data.sessionId, data, { ex: SESSION_TTL_SECONDS });
  } catch(error) {
    console.error("[SESSION-CRITICAL] KV Error saving session:", error);
    throw new SessionStoreUnavailableError('The session store is currently unavailable during save.');
  }
}

export async function destroySession(): Promise<void> {
  const session = await getIronSession<SessionIdContainer>(await cookies(), sessionOptions);
  const sessionId = session.sessionId;

  if (sessionId) {
    await kv.del(sessionId);
  }
  
  session.destroy();
}